
import { CaptionTrack, TranscriptStrategy } from './types.ts';

export class WebScrapingStrategy implements TranscriptStrategy {
  name = 'web-scraping';

  async fetchTranscript(videoId: string): Promise<string> {
    console.log(`🌐 Web Scraping: Extracting from ${videoId}`);

    const watchUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const response = await fetch(watchUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
        'Accept-Language': 'en-US,en;q=0.9',
        'Cache-Control': 'no-cache'
      }
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch YouTube page: ${response.status}`);
    }

    const html = await response.text();
    console.log(`📄 HTML length: ${html.length}`);

    // Extract caption tracks from HTML
    const captionTracks = this.extractCaptionTracks(html);
    
    if (captionTracks.length === 0) {
      throw new Error('No caption tracks found in page HTML');
    }

    // Select best track and download
    const bestTrack = this.selectBestTrack(captionTracks);
    return await this.downloadCaptionContent(bestTrack.baseUrl);
  }

  private extractCaptionTracks(html: string): CaptionTrack[] {
    const patterns = [
      /"captionTracks":\s*\[([^\]]+)\]/,
      /"captions":\s*\{[^}]*"playerCaptionsTracklistRenderer":\s*\{[^}]*"captionTracks":\s*\[([^\]]+)\]/,
      /var\s+ytInitialPlayerResponse\s*=\s*\{[^}]*"captions":[^}]*"captionTracks":\s*\[([^\]]+)\]/,
      /"playerMicroformatRenderer":[^}]*"captions":[^}]*"captionTracks":\s*\[([^\]]+)\]/
    ];

    for (const pattern of patterns) {
      const match = html.match(pattern);
      if (match) {
        try {
          const tracksData = JSON.parse(`[${match[1]}]`);
          console.log(`✅ Found ${tracksData.length} caption tracks`);
          
          return tracksData.map((track: any) => ({
            languageCode: track.languageCode || 'unknown',
            languageName: track.name?.simpleText || track.languageCode || 'Unknown',
            baseUrl: track.baseUrl,
            kind: track.kind,
            isAutoGenerated: track.kind === 'asr'
          }));
        } catch (e) {
          console.log(`❌ Failed to parse caption tracks: ${e.message}`);
          continue;
        }
      }
    }

    return [];
  }

  private selectBestTrack(tracks: CaptionTrack[]): CaptionTrack {
    // Preference: manual English > auto English > manual other > auto other
    return tracks.find(track => 
      track.languageCode === 'en' && !track.isAutoGenerated
    ) || tracks.find(track => 
      track.languageCode === 'en'
    ) || tracks.find(track => 
      !track.isAutoGenerated
    ) || tracks[0];
  }

  private async downloadCaptionContent(captionUrl: string): Promise<string> {
    console.log(`🔗 Downloading captions from: ${captionUrl.substring(0, 100)}...`);
    
    const response = await fetch(captionUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Accept': 'text/xml,application/xml,*/*'
      }
    });

    if (!response.ok) {
      throw new Error(`Failed to download caption content: ${response.status}`);
    }

    const content = await response.text();
    console.log(`📄 Caption content length: ${content.length}`);
    
    if (!content.includes('<text') && !content.includes('WEBVTT')) {
      throw new Error('Invalid caption content format');
    }

    return content;
  }
}
