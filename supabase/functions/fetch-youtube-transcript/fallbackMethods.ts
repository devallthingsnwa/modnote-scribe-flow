import { corsHeaders, extractVideoId, validateVideoId } from "./utils.ts";
import { ContentParser } from "./contentParser.ts";

interface TranscriptOptions {
  language?: string;
  autoGenerated?: boolean;
  format?: 'json' | 'text' | 'srt' | 'vtt';
}

export class FallbackMethods {
  private contentParser: ContentParser;

  constructor() {
    this.contentParser = new ContentParser();
  }
  
  async tryAllMethods(videoUrl: string, options: TranscriptOptions = {}): Promise<Response | null> {
    const videoId = extractVideoId(videoUrl);
    
    if (!videoId || !validateVideoId(videoId)) {
      return this.createErrorResponse("Invalid YouTube video URL or ID", 400);
    }

    console.log(`üéØ Starting transcript extraction for: ${videoId}`);
    console.log(`üîó Video URL: ${videoUrl}`);

    const methods = [
      () => this.methodDirectCaptionAPI(videoId, options),
      () => this.methodYouTubeWatch(videoId, options),
      () => this.methodYouTubeAPI(videoId, options),
      () => this.methodAlternateCaptionAPI(videoId, options)
    ];

    for (let i = 0; i < methods.length; i++) {
      try {
        console.log(`üîç Trying method ${i + 1}/${methods.length}`);
        const result = await methods[i]();
        
        if (result) {
          console.log(`‚úÖ Method ${i + 1} successful`);
          return result;
        }
      } catch (error) {
        console.log(`‚ùå Method ${i + 1} failed:`, error.message);
      }
    }

    return this.createErrorResponse("No transcript available for this video", 404);
  }

  private async methodDirectCaptionAPI(videoId: string, options: TranscriptOptions): Promise<Response | null> {
    try {
      console.log("üîç Attempting direct caption API...");
      
      // Extended list of caption URL formats prioritizing working ones
      const captionUrls = [
        `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en&fmt=srv3`,
        `https://www.youtube.com/api/timedtext?v=${videoId}&lang=auto&fmt=srv3`,
        `https://www.youtube.com/api/timedtext?v=${videoId}&fmt=srv3`,
        `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en-US&fmt=srv3`,
        `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en&fmt=srv1`,
        `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en&fmt=ttml`,
        `https://video.google.com/timedtext?lang=en&v=${videoId}`,
        `https://www.youtube.com/api/timedtext?v=${videoId}&tlang=en&fmt=srv3`,
        `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en&fmt=srv3&kind=asr`,
        `https://www.youtube.com/api/timedtext?v=${videoId}&lang=tl&fmt=srv3`,
        `https://www.youtube.com/api/timedtext?v=${videoId}&lang=fil&fmt=srv3`,
        `https://www.youtube.com/api/timedtext?v=${videoId}&fmt=srv3&auto=1`,
        `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en&fmt=vtt`,
        `https://www.youtube.com/api/timedtext?v=${videoId}&lang=auto&fmt=vtt`,
        `https://www.youtube.com/api/timedtext?v=${videoId}&fmt=vtt`
      ];

      for (const url of captionUrls) {
        try {
          console.log(`üîó Testing: ${url}`);
          
          const response = await fetch(url, {
            headers: {
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
              'Accept': 'text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5',
              'Accept-Language': 'en-US,en;q=0.5',
              'Referer': `https://www.youtube.com/watch?v=${videoId}`,
              'Cache-Control': 'no-cache'
            }
          });

          console.log(`üìä Status: ${response.status}`);
          console.log(`üìä Content-Type: ${response.headers.get('content-type')}`);
          
          if (response.ok) {
            const content = await response.text();
            console.log(`üìÑ Content length: ${content.length}`);
            console.log(`üìù Content preview: ${content.substring(0, 200)}...`);
            console.log(`‚úÖ Has <text> tags: ${content.includes('<text')}`);
            console.log(`‚úÖ Has WEBVTT: ${content.includes('WEBVTT')}`);
            
            if ((content.includes('<text') || content.includes('WEBVTT')) && content.length > 100) {
              console.log(`‚úÖ Found valid captions, processing...`);
              const result = await this.contentParser.processTranscriptContent(content, 'direct-caption-api');
              if (result) {
                return result;
              }
            }
          }
        } catch (error) {
          console.log(`‚ùå URL failed: ${error.message}`);
        }
      }

      return null;
    } catch (error) {
      console.error("Direct caption API method failed:", error);
      return null;
    }
  }

  private async methodYouTubeWatch(videoId: string, options: TranscriptOptions): Promise<Response | null> {
    try {
      console.log("üîç Attempting YouTube watch page scraping...");
      
      const watchUrl = `https://www.youtube.com/watch?v=${videoId}`;
      const response = await fetch(watchUrl, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
          'Accept-Language': 'en-US,en;q=0.9',
          'Accept-Encoding': 'gzip, deflate, br',
          'DNT': '1',
          'Connection': 'keep-alive',
          'Upgrade-Insecure-Requests': '1'
        }
      });

      if (!response.ok) {
        console.log(`‚ùå Watch page failed: ${response.status}`);
        return null;
      }

      const html = await response.text();
      console.log(`üìÑ HTML length: ${html.length}`);

      const patterns = [
        /"captionTracks":\s*\[([^\]]+)\]/,
        /"captions":\s*\{[^}]*"playerCaptionsTracklistRenderer":\s*\{[^}]*"captionTracks":\s*\[([^\]]+)\]/,
        /var\s+ytInitialPlayerResponse\s*=\s*\{[^}]*"captions":[^}]*"captionTracks":\s*\[([^\]]+)\]/,
        /"playerMicroformatRenderer":[^}]*"captions":[^}]*"captionTracks":\s*\[([^\]]+)\]/,
        /"webPlayerActionsPorting":[^}]*"captions":[^}]*"captionTracks":\s*\[([^\]]+)\]/,
        /window\.ytplayer\.config\s*=\s*\{[^}]*"captions":[^}]*"captionTracks":\s*\[([^\]]+)\]/
      ];

      let captionTracks = null;

      for (const pattern of patterns) {
        const match = html.match(pattern);
        if (match) {
          try {
            console.log(`üìù Found pattern match: ${match[1].substring(0, 100)}...`);
            captionTracks = JSON.parse(`[${match[1]}]`);
            console.log(`‚úÖ Parsed ${captionTracks.length} caption tracks`);
            break;
          } catch (e) {
            console.log(`‚ùå Failed to parse: ${e.message}`);
            continue;
          }
        }
      }

      if (captionTracks && captionTracks.length > 0) {
        let bestTrack = captionTracks.find((track: any) => track.languageCode === 'en') ||
                      captionTracks.find((track: any) => track.languageCode === 'tl') ||
                      captionTracks.find((track: any) => track.languageCode === 'fil') ||
                      captionTracks.find((track: any) => track.kind !== 'asr') ||
                      captionTracks[0];

        if (bestTrack && bestTrack.baseUrl) {
          console.log(`üéØ Using track: ${bestTrack.languageCode || 'unknown'}`);
          console.log(`üîó Caption URL: ${bestTrack.baseUrl}`);
          
          const captionResponse = await fetch(bestTrack.baseUrl);
          if (captionResponse.ok) {
            const captionXml = await captionResponse.text();
            console.log(`üìÑ Caption XML length: ${captionXml.length}`);
            
            if (captionXml.includes('<text')) {
              console.log(`‚úÖ Found valid caption XML`);
              return await this.contentParser.processTranscriptContent(captionXml, 'youtube-watch-scraping');
            }
          }
        }
      } else {
        console.log("‚ùå No caption tracks found in HTML");
      }

      return null;
    } catch (error) {
      console.error("YouTube watch method failed:", error);
      return null;
    }
  }

  private async methodYouTubeAPI(videoId: string, options: TranscriptOptions): Promise<Response | null> {
    try {
      console.log("üîç Attempting YouTube Data API v3...");
      
      const apiKey = Deno.env.get('YOUTUBE_API_KEY');
      if (!apiKey) {
        console.log("‚ùå YouTube API key not found, skipping API method");
        return null;
      }

      const videoResponse = await fetch(
        `https://www.googleapis.com/youtube/v3/videos?id=${videoId}&key=${apiKey}&part=snippet`
      );

      if (!videoResponse.ok) {
        console.log(`‚ùå YouTube API error: ${videoResponse.status}`);
        return null;
      }

      const videoData = await videoResponse.json();
      
      if (!videoData.items || videoData.items.length === 0) {
        console.log("‚ùå Video not found via API");
        return null;
      }

      console.log("‚úÖ Video found via API but caption download requires OAuth");
      return null;
    } catch (error) {
      console.error("YouTube API method failed:", error);
      return null;
    }
  }

  private async methodAlternateCaptionAPI(videoId: string, options: TranscriptOptions): Promise<Response | null> {
    try {
      console.log("üîç Attempting alternate caption methods...");
      
      const alternateUrls = [
        `https://youtube.googleapis.com/youtube/v3/captions/${videoId}`,
        `https://www.youtube.com/get_video_info?video_id=${videoId}`,
        `https://www.youtube.com/youtubei/v1/player?videoId=${videoId}`
      ];

      for (const url of alternateUrls) {
        try {
          console.log(`üîó Testing alternate: ${url}`);
          const response = await fetch(url);
          
          if (response.ok) {
            const content = await response.text();
            console.log(`üìÑ Alternate content length: ${content.length}`);
            
            if (content.includes('captionTracks') || content.includes('<text')) {
              console.log(`‚úÖ Found potential captions in alternate method`);
            }
          }
        } catch (error) {
          console.log(`‚ùå Alternate URL failed: ${error.message}`);
        }
      }

      return null;
    } catch (error) {
      console.error("Alternate caption method failed:", error);
      return null;
    }
  }

  private createErrorResponse(message: string, status: number): Response {
    return new Response(
      JSON.stringify({ 
        success: false, 
        error: message,
        transcript: `Unable to fetch transcript: ${message}`,
        metadata: {
          segments: 0,
          duration: 0,
          hasTimestamps: false,
          source: 'error'
        }
      }),
      {
        status,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      }
    );
  }
}
