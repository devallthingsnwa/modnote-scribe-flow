import { corsHeaders, extractVideoId, validateVideoId, extractVideoTitle, extractChannelName } from "./utils.ts";
import { ContentParser } from "./contentParser.ts";

interface TranscriptOptions {
  language?: string;
  autoGenerated?: boolean;
  format?: 'json' | 'text' | 'srt' | 'vtt';
}

export class FallbackMethods {
  private contentParser: ContentParser;

  constructor() {
    this.contentParser = new ContentParser();
  }
  
  async tryAllMethods(videoUrl: string, options: TranscriptOptions = {}): Promise<Response | null> {
    const videoId = extractVideoId(videoUrl);
    
    if (!videoId || !validateVideoId(videoId)) {
      return this.createErrorResponse("Invalid YouTube video URL or ID", 400);
    }

    console.log(`üéØ Starting transcript extraction for video: ${videoId}`);

    const methods = [
      () => this.methodYouTubeCaption(videoId, videoUrl, options),
      () => this.methodYouTubeWatch(videoId, videoUrl, options),
      () => this.methodAlternativeAPIs(videoId, videoUrl, options),
      () => this.methodYouTubeEmbed(videoId, videoUrl, options)
    ];

    const methodNames = ['Direct Caption API', 'Watch Page Scraping', 'Alternative APIs', 'Embed Scraping'];
    let lastError = '';

    for (let i = 0; i < methods.length; i++) {
      try {
        console.log(`üîç Testing Method ${i + 1}: ${methodNames[i]}`);
        const result = await methods[i]();
        
        if (result) {
          console.log(`‚úÖ SUCCESS: Method ${i + 1} (${methodNames[i]}) extracted transcript`);
          return result;
        }
        console.log(`‚ùå Method ${i + 1} (${methodNames[i]}) failed - no content found`);
      } catch (error) {
        const errorMsg = `Method ${i + 1} (${methodNames[i]}): ${error.message}`;
        console.log(`‚ùå ${errorMsg}`);
        lastError += errorMsg + '. ';
      }
    }

    return this.createErrorResponse(`All extraction methods failed. ${lastError}`, 404);
  }

  private async methodYouTubeCaption(videoId: string, videoUrl: string, options: TranscriptOptions): Promise<Response | null> {
    console.log("üîç Testing Method 1: Direct Caption API");
    
    // Comprehensive list of caption URL formats to try
    const captionUrls = [
      `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en&fmt=srv3`,
      `https://www.youtube.com/api/timedtext?v=${videoId}&lang=auto&fmt=srv3`,
      `https://www.youtube.com/api/timedtext?v=${videoId}&fmt=srv3&auto=1`,
      `https://video.google.com/timedtext?lang=en&v=${videoId}`,
      `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en-US&fmt=srv1`,
      `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en&fmt=ttml`,
      `https://www.youtube.com/api/timedtext?v=${videoId}&tlang=en`,
      `https://www.youtube.com/api/timedtext?v=${videoId}&lang=${options.language || 'en'}&fmt=srv3`,
      `https://www.youtube.com/api/timedtext?v=${videoId}&fmt=srv3`,
      `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en&fmt=vtt`,
      `https://www.youtube.com/api/timedtext?v=${videoId}&lang=auto&fmt=vtt`
    ];

    for (let i = 0; i < captionUrls.length; i++) {
      const url = captionUrls[i];
      try {
        console.log(`üìä URL ${i + 1}: ${url}`);
        
        const response = await fetch(url, {
          headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'text/xml,application/xml,text/plain,*/*',
            'Accept-Language': 'en-US,en;q=0.9',
          }
        });

        console.log(`üìä Response Status: ${response.status}`);
        console.log(`üìÑ Content Type: ${response.headers.get('content-type')}`);

        if (response.ok) {
          const content = await response.text();
          console.log(`üìù Content Length: ${content.length}`);
          console.log(`üìù Content Preview: ${content.substring(0, 200)}...`);
          console.log(`‚úÖ Has <text> tags: ${content.includes('<text')}`);
          
          if (content.length > 100 && (content.includes('<text') || content.includes('WEBVTT'))) {
            const { title, author } = await this.getVideoMetadata(videoId);
            
            const metadata = {
              videoId,
              title,
              author,
              url: videoUrl,
              language: options.language || 'en',
              extractionMethod: 'direct-caption-api'
            };
            
            return await this.contentParser.processTranscriptContent(
              content,
              'direct-caption-api',
              metadata
            );
          }
        }
      } catch (error) {
        console.log(`‚ùå Caption URL ${i + 1} failed: ${error.message}`);
      }
    }

    return null;
  }

  private async methodYouTubeWatch(videoId: string, videoUrl: string, options: TranscriptOptions): Promise<Response | null> {
    console.log("üîç Testing Method 2: Watch Page Scraping");
    
    try {
      const watchUrl = `https://www.youtube.com/watch?v=${videoId}`;
      console.log(`üìä Fetching: ${watchUrl}`);
      
      const response = await fetch(watchUrl, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
          'Accept-Language': 'en-US,en;q=0.9',
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
          'Cache-Control': 'no-cache',
        }
      });

      console.log(`üìä Watch page status: ${response.status}`);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      const html = await response.text();
      console.log(`üìù HTML length: ${html.length}`);
      
      // Extract video metadata from HTML
      const title = extractVideoTitle(html);
      const author = extractChannelName(html);
      console.log(`üìä Video: "${title}" by ${author}`);
      
      // Modern caption patterns for 2024 YouTube
      const modernCaptionPatterns = [
        /"captionTracks":\s*\[([^\]]+)\]/,
        /"captions":\s*\{[^}]*"playerCaptionsTracklistRenderer":\s*\{[^}]*"captionTracks":\s*\[([^\]]+)\]/,
        /var\s+ytInitialPlayerResponse\s*=\s*\{[^}]*"captions":[^}]*"captionTracks":\s*\[([^\]]+)\]/,
        /"playerMicroformatRenderer":[^}]*"captions":[^}]*"captionTracks":\s*\[([^\]]+)\]/,
        /\"captionTracks\":\[([^\]]*)\]/,
        /"playerResponse".*?"captions".*?"captionTracks":\[([^\]]+)\]/
      ];
      
      let captionTracks = null;
      
      for (let i = 0; i < modernCaptionPatterns.length; i++) {
        const pattern = modernCaptionPatterns[i];
        const match = html.match(pattern);
        console.log(`üìä Pattern ${i + 1} match: ${match ? 'FOUND' : 'not found'}`);
        
        if (match) {
          try {
            captionTracks = JSON.parse(`[${match[1]}]`);
            console.log(`‚úÖ Parsed ${captionTracks.length} caption tracks`);
            break;
          } catch (e) {
            console.log(`‚ùå Failed to parse pattern ${i + 1}: ${e.message}`);
            continue;
          }
        }
      }
      
      if (!captionTracks || captionTracks.length === 0) {
        console.log("‚ùå No caption tracks found in HTML");
        return null;
      }

      // Find best caption track
      const languagePriority = [options.language || 'en', 'en', 'auto', 'en-US', 'en-GB'];
      let selectedTrack = null;
      
      for (const lang of languagePriority) {
        selectedTrack = captionTracks.find((track: any) => track.languageCode === lang);
        if (selectedTrack) {
          console.log(`‚úÖ Selected track language: ${lang}`);
          break;
        }
      }
      
      if (!selectedTrack) {
        selectedTrack = captionTracks[0];
        console.log(`‚úÖ Using first available track: ${selectedTrack.languageCode}`);
      }
      
      if (!selectedTrack?.baseUrl) {
        console.log("‚ùå No baseUrl found in selected track");
        return null;
      }

      // Download caption content
      console.log(`üìä Downloading captions from: ${selectedTrack.baseUrl}`);
      const captionResponse = await fetch(selectedTrack.baseUrl, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
          'Accept': 'text/xml,application/xml,*/*',
        }
      });

      if (!captionResponse.ok) {
        throw new Error(`Caption download failed: ${captionResponse.status}`);
      }

      const captionContent = await captionResponse.text();
      console.log(`üìù Caption content length: ${captionContent.length}`);
      console.log(`üìù Caption preview: ${captionContent.substring(0, 200)}...`);

      if (captionContent.length < 50) {
        console.log("‚ùå Caption content too short");
        return null;
      }

      const metadata = {
        videoId,
        title,
        author,
        url: videoUrl,
        language: selectedTrack.languageCode || 'en',
        extractionMethod: 'youtube-watch-scraping'
      };
      
      return await this.contentParser.processTranscriptContent(
        captionContent,
        'youtube-watch-scraping',
        metadata
      );

    } catch (error) {
      console.error(`‚ùå Watch page scraping failed: ${error.message}`);
      return null;
    }
  }

  private async methodAlternativeAPIs(videoId: string, videoUrl: string, options: TranscriptOptions): Promise<Response | null> {
    console.log("üîç Testing Method 3: Alternative APIs");
    
    // Try alternative caption endpoints
    const altEndpoints = [
      `https://video.google.com/timedtext?lang=auto&v=${videoId}`,
      `https://video.google.com/timedtext?lang=en&v=${videoId}&fmt=srv3`,
      `https://www.youtube.com/api/timedtext?v=${videoId}&asr_langs=en,auto&caps=asr&exp=xftt,yt6&xoaf=4&hl=en&ip=0.0.0.0&ipbits=0&expire=1999999999&sparams=ip,ipbits,expire,v,asr_langs,caps,exp,xoaf&signature=dummy&key=dummy`
    ];

    for (let i = 0; i < altEndpoints.length; i++) {
      const url = altEndpoints[i];
      try {
        console.log(`üìä Alternative API ${i + 1}: ${url}`);
        
        const response = await fetch(url, {
          headers: {
            'User-Agent': 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)',
            'Accept': 'text/xml,application/xml,*/*'
          }
        });

        console.log(`üìä Alt API ${i + 1} status: ${response.status}`);

        if (response.ok) {
          const content = await response.text();
          console.log(`üìù Alt API ${i + 1} content length: ${content.length}`);
          
          if (content.length > 100 && content.includes('<text')) {
            const { title, author } = await this.getVideoMetadata(videoId);
            
            const metadata = {
              videoId,
              title,
              author,
              url: videoUrl,
              language: options.language || 'en',
              extractionMethod: 'alternative-api'
            };
            
            return await this.contentParser.processTranscriptContent(
              content,
              'alternative-api',
              metadata
            );
          }
        }
      } catch (error) {
        console.log(`‚ùå Alternative API ${i + 1} failed: ${error.message}`);
      }
    }

    return null;
  }

  private async methodYouTubeEmbed(videoId: string, videoUrl: string, options: TranscriptOptions): Promise<Response | null> {
    console.log("üîç Testing Method 4: Embed Scraping");
    
    try {
      const embedUrl = `https://www.youtube.com/embed/${videoId}`;
      const response = await fetch(embedUrl, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
      });

      console.log(`üìä Embed page status: ${response.status}`);

      if (response.ok) {
        const html = await response.text();
        console.log(`üìù Embed HTML length: ${html.length}`);
        
        // Look for caption tracks in embed page
        const captionMatch = html.match(/"captionTracks":\s*\[([^\]]+)\]/);
        if (captionMatch) {
          try {
            const tracks = JSON.parse(`[${captionMatch[1]}]`);
            if (tracks.length > 0 && tracks[0].baseUrl) {
              console.log(`‚úÖ Found ${tracks.length} caption tracks in embed`);
              
              const captionResponse = await fetch(tracks[0].baseUrl);
              const captionContent = await captionResponse.text();
              
              if (captionContent.length > 50) {
                const { title, author } = await this.getVideoMetadata(videoId);
                
                const metadata = {
                  videoId,
                  title,
                  author,
                  url: videoUrl,
                  language: tracks[0].languageCode || 'en',
                  extractionMethod: 'embed-scraping'
                };
                
                return await this.contentParser.processTranscriptContent(
                  captionContent,
                  'embed-scraping',
                  metadata
                );
              }
            }
          } catch (e) {
            console.log(`‚ùå Failed to parse embed captions: ${e.message}`);
          }
        }
      }

      return null;
    } catch (error) {
      console.error(`‚ùå Embed scraping failed: ${error.message}`);
      return null;
    }
  }

  private async getVideoMetadata(videoId: string): Promise<{ title: string; author: string }> {
    try {
      const watchResponse = await fetch(`https://www.youtube.com/watch?v=${videoId}`, {
        headers: { 
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36' 
        }
      });
      
      if (watchResponse.ok) {
        const watchHtml = await watchResponse.text();
        return {
          title: extractVideoTitle(watchHtml),
          author: extractChannelName(watchHtml)
        };
      }
    } catch (e) {
      console.log("Failed to fetch video metadata:", e.message);
    }
    
    return {
      title: 'Unknown Video',
      author: 'Unknown Channel'
    };
  }

  private createErrorResponse(message: string, status: number): Response {
    console.log(`‚ùå Creating error response: ${message}`);
    
    return new Response(
      JSON.stringify({ 
        success: false, 
        error: message,
        transcript: `Unable to fetch transcript - ${message.toLowerCase()}`,
        metadata: {
          videoId: '',
          title: 'Error',
          author: '',
          url: '',
          language: '',
          duration: 0,
          segmentCount: 0,
          extractionMethod: 'error',
          hasTimestamps: false,
          source: 'error'
        }
      }),
      {
        status,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      }
    );
  }
}
